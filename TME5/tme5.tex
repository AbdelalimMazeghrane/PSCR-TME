\section*{TME 5~: Parallélisation d'une application}
\thispagestyle{plain}\rhead{TME 5}
\setcounter{section}{1}
\setcounter{subsection}{0}
\setcounter{figure}{0}
\setcounter{questioncounter}{0}
\label{tme:5}

\par\noindent\textbf{Objectifs pédagogiques~:
\begin{itemize}
	\item condition, mutex, barrière 
	\item pool de threads
	\item parallélisation d'une application
\end{itemize}
}

\subsection{Objectif}

On vous fournit le code d'un Ray tracer très basique, qui sait dessiner des scenes représentant des Spheres colorées avec un éclairage. Le code est basique mais inspectable; il y eu une époque avant les GPU où le rendu 3D avec des ellipsoides était à la  mode, cf e.g. Ecstatica II (circa 1997) pour un jeu commercial basé simplement sur cette technique.

Pour cela, le code calcule la couleur de chaque pixel de l'image à l'aide d'un rayon tiré de l'observateur (la caméra) vers les points de l'écran. La couleur du pixel dépend de la couleur de la première sphère intersectée par le rayon, et de l'éclairage (position des sources lumineuses) en ce point.

On a pour calculer l'image actuellement une double boucle imbriquée qui calcule la couleur des pixels pour chaque position dans l'écran.

\includegraphics[angle=0,origin=c,height=8cm]{tme/tme5/ray.png}

Votre mission (si vous l'acceptez) est de paralléliser ce code. A priori la tâche est assez facile : la couleur de chaque pixel peut tout à fait être calculée en parallèle (le problème est "Embarrassingly parallel").
Le calcul de la couleur nécessite un accès en lecture seule sur l'état de la scene qui contient les sphères.

\subsection{Baseline séquentiel}

\question Extraire le TME5.zip pris sur le moodle dans un dossier de votre repo, puis faire un git add/commit/push de ce code initial.
Lancer la configuration du projet (cf le Readme), on utilise CMake comme les TME précédents. 
Pas de dépendances sur ce projet (tout est fait "à la main"). 

\question Lancer le programme ``build/TME5'' et admirer l'image générée ``spheres.bmp''.
Browser l'ensemble du code pour se familiariser avec son fonctionnement. 
Lancez en augmentant la résolution avec -W et -H, jusqu'a atteindre un temps séquentiel (en mode release) de quelques secondes (plus que 3 est bien). Le défaut est -W 2000 -H 2000 déjà.
Tracez vos temps et votre plateforme (e.g. cores, nombre et fréquence/type, RAM, compilo, OS, type de stockage SDD/HDD/NFS).


Explorez rapidement le code~:
\begin{itemize}
\item La classe Vec3D est une classe de vecteurs 3D, avec des opérations usuelles (codées comme des opérateurs). 
\item La classe Scene représente une scène 3D, elle contient les sphères, les lumières et la caméra. Le tout en positions 3D.
\item Une Sphere est définie par son centre (un Vec3D), son rayon et sa couleur.
\item Un Ray est défini par son origine et sa direction, deux Vec3D.
\item La méthode Scene::getColor(Ray) calcule la couleur vue par un rayon. 
Pour celà on prolonge le rayon jusqu'à intersecter une sphere (ou le fond). 
La couleur quand on rencontre une sphere prend en compte son éclairage.
\item La classe Image est un bitmap RGB 24 bits, avec une méthode pour écrire un fichier BMP.
Elle alloue un tableau de Color, une classe simple avec trois octets r,g,b.
\item La classe Renderer fait le rendu de la scene dans une image. C'est là que se trouve la double boucle imbriquée sur les pixels.
\item La classe SceneBuilder construit une scène (presque) aléatoire.
\item Le main parse les options, crée une scene, un renderer et lance le rendu.
\end{itemize}

\subsection{Avec des threads "à la main"}

\question Dans la classe Renderer, créez une méthode \texttt{void renderThreadPerPixel(const Scene& scene, Image& img)} 
qui crée un thread par pixel (donc $W*H$ threads) pour calculer la couleur de chaque pixel en parallèle.
Attention on ne revient de la méthode que lorsque l'image est entièrement rendue.
Dans le main introduisez un mode "-m ThreadPerPixel"  qui utilise cette méthode au lieu de "render".
Attention, il peut falloir limiter la résolution, ça va être lent... 

\question Dans la classe Renderer, créez une méthode \texttt{void renderThreadPerRow(const Scene& scene, Image& img)} 
qui crée un thread par ligne (donc $H$ threads) pour calculer la couleur de chaque ligne de pixel en parallèle.
Attention on ne revient de la méthode que lorsque l'image est entièrement rendue.
Dans le main introduisez un mode "-m TreadPerRow" qui utilise cette méthode au lieu de "render".
Attention, il peut falloir limiter la résolution, mais normalement ça va déjà un peu mieux.

\question Dans la classe Renderer, créez une méthode \texttt{void renderThreadManual(const Scene& scene, Image& img, int nbthread)}
qui crée \texttt{nbthread} threads pour calculer la couleur des pixels en parallèle.
Chaque thread doit traiter une partie de l'image à peu près équitable, e.g. on calcule environ H/nbthread lignes par thread (attention au reste).
Dans le main introduisez un mode "-m ThreadManual" qui utilise cette méthode et l'argument "-n/--nbthread" pour le nombre de threads, 
au lieu de "render".
Cette méthode est efficace, avec un peu plus de threads que de coeurs on doit être proche d'une accélération linéaire.
Cherchez le réglage qui marche le mieux sur votre machine.

\subsection{Avec un pool de threads}

\question Créez la classe Queue avec son comportement final dans le TD : comportement bloquant par défaut, possibilité de basculer à non bloquant si on le souhaite.
On vous donne le cadre de la classe dans une version thread safe mais non bloquante (voir Queue.h).

\question Créez la classe Pool avec son comportement final dans le TD : 
construction avec la taille de la queue, start, stop. La classe abstraite (interface) Job et sa méthode virtuelle pure "run" sont fournis dans Job.h.

\begin{prof}

cf corrigé du TD

\end{prof}

\question Créez un Job concret PixelJob qui permet de calculer et mettre à jour dans l'image la couleur d'un pixel donné (x, y).
Attention, on ne fait pas des lambdas, on crée une classe dérivée de Job, donc à vous de capturer les paramètres nécessaires explicitement
(attributs, constructeur). Attention à capturer par référence ou par valeur selon le cas.
Utilisez cette classe dans une nouvelle méthode \texttt{renderPoolPixel} de Renderer qui utilise un Pool pour faire le rendu.
Ajoutez un mode "-m PoolPixel" (Thread Pool) dans le main pour utiliser cette méthode (on passera aussi -n pour le nombre de threads dans le pool).
Réflechissez un peu sur la taille de la queue qui serait appropriée ici.
Testez, attention il y a beaucoup de frottements sur la soumission de jobs, alors que chaque job est très rapide; sans être aussi mauvais que ThreadPerPixel on ne s'attend pas 
à ce que soit très bon.


\begin{prof}

Ca nous donne ça plus ou moins :


\begin{lstinputlisting}[language=java,style=eclipse_file,title=\texttt{Queue.h}]
{tme/tme4cor/src/main.cpp}
\end{lstinputlisting}

\end{prof}


\question Créez un Job concret LineJob qui permet de calculer et mettre à jour dans l'image la couleur d'une ligne de pixels donnée.
Attention, comme la précédente il faut faire une capture à la main du contexte.
Utilisez cette classe dans une nouvelle méthode \texttt{renderPoolRow} de Renderer qui utilise un Pool pour faire le rendu.
Ajoutez un mode "-m PoolRow" (Thread Pool) dans le main pour utiliser cette méthode (on passera aussi -n pour le nombre de threads dans le pool).
Réflechissez un peu sur la taille de la queue qui serait appropriée ici.
On doit avec un paramétrage adapté tourner quasiment $N$ fois plus vite sur une machine avec $N$ coeurs avec cette solution,
avec moins d'effort d'une certaine manière que ThreadManual. Si le render de parties de l'image est déséquilibré 
(e.g. une image à moitié vide, mais une partie avec des reflections et une scene dense...) cette solution
 équilibre potentiellement mieux la charge. Ici ce n'est pas le cas avec notre ray tracer très basique.


\begin{prof}

TODO

\end{prof}

\question Concluez sur la meilleure configuration identifiée sur votre machine.


\subsection{Bonus}

\question Mettez à jour l'API du Pool, pour permettre de soumettre des lambdas (std::function<void()>)
au lieu de Job. 
Notons que si on renomme "void run()" en "void operator()()" dans Job, on pourra aussi soumettre des Job via cette API.

